diff --git a/dist/shared/bumpp.0D8oR-Fd.mjs b/dist/shared/bumpp.0D8oR-Fd.mjs
index bae655794606bdf7f45d949b9bcb3a4260ef0c9a..b514ee6d37c384ccec32a3272979d66890e3cfc1 100644
--- a/dist/shared/bumpp.0D8oR-Fd.mjs
+++ b/dist/shared/bumpp.0D8oR-Fd.mjs
@@ -6942,7 +6942,12 @@ async function updateFile(relPath, operation) {
     case "jsr.jsonc":
     case "deno.json":
     case "deno.jsonc":
+    case "tauri.conf.json":
       return updateManifestFile(relPath, operation);
+    case "cargo.toml":
+      return updateCargoToml(relPath, operation);
+    case "cargo.lock":
+      return updateCargoLock(relPath, operation);
     default:
       return updateTextFile(relPath, operation);
   }
@@ -6952,7 +6957,9 @@ async function updateManifestFile(relPath, operation) {
   const { newVersion } = operation.state;
   let modified = false;
   const file = await readJsoncFile(relPath, cwd);
-  if (!isManifest(file.data)) {
+  // Support files with only version field (like tauri.conf.json)
+  const hasVersion = file.data && typeof file.data === "object" && typeof file.data.version === "string";
+  if (!isManifest(file.data) && !hasVersion) {
     return modified;
   }
   if (file.data.version == null) {
@@ -6967,6 +6974,62 @@ async function updateManifestFile(relPath, operation) {
   }
   return modified;
 }
+async function updateCargoToml(relPath, operation) {
+  const { cwd } = operation.options;
+  const { currentVersion, newVersion } = operation.state;
+  let modified = false;
+  const file = await readTextFile(relPath, cwd);
+  // Match version in [package] section: version = "x.y.z"
+  const versionPattern = new RegExp(`(^\\s*version\\s*=\\s*["']?)${currentVersion.replace(/(\W)/g, "\\$1")}(["']?\\s*$)`, "m");
+  if (versionPattern.test(file.data)) {
+    file.data = file.data.replace(versionPattern, `$1${newVersion}$2`);
+    await writeTextFile(file);
+    modified = true;
+  }
+  return modified;
+}
+async function updateCargoLock(relPath, operation) {
+  const { cwd } = operation.options;
+  const { currentVersion, newVersion } = operation.state;
+  let modified = false;
+  const file = await readTextFile(relPath, cwd);
+  // Only update the main package version, not dependencies
+  // Read the package name from Cargo.toml to identify the main package
+  const lockDir = path.dirname(path.join(cwd, relPath));
+  const cargoTomlPath = path.join(lockDir, "Cargo.toml");
+  let packageName = null;
+  if (existsSync(cargoTomlPath)) {
+    const cargoTomlRelPath = path.relative(cwd, cargoTomlPath);
+    const cargoTomlContent = await readTextFile(cargoTomlRelPath, cwd);
+    const nameMatch = cargoTomlContent.data.match(/^name\s*=\s*["']([^"']+)["']/m);
+    if (nameMatch) {
+      packageName = nameMatch[1];
+    }
+  }
+  if (packageName) {
+    // Match version only for the main package: [[package]] followed by name = "package-name" followed by version = "x.y.z"
+    // Use multiline mode and allow flexible whitespace
+    const escapedPackageName = packageName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+    const escapedCurrentVersion = currentVersion.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+    // Pattern: [[package]] ... name = "package-name" ... version = "currentVersion"
+    const mainPackagePattern = new RegExp(`(\\[\\[package\\]\\][\\s\\S]*?name\\s*=\\s*["']${escapedPackageName}["'][\\s\\S]*?version\\s*=\\s*["']?)${escapedCurrentVersion}(["'])`, "m");
+    if (mainPackagePattern.test(file.data)) {
+      file.data = file.data.replace(mainPackagePattern, `$1${newVersion}$2`);
+      await writeTextFile(file);
+      modified = true;
+    }
+  } else {
+    // Fallback: only replace first occurrence (likely the main package)
+    const escapedCurrentVersion = currentVersion.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
+    const versionPattern = new RegExp(`(^version\\s*=\\s*["']?)${escapedCurrentVersion}(["']\\s*$)`, "m");
+    if (versionPattern.test(file.data)) {
+      file.data = file.data.replace(versionPattern, `$1${newVersion}$2`);
+      await writeTextFile(file);
+      modified = true;
+    }
+  }
+  return modified;
+}
 async function updateTextFile(relPath, operation) {
   const { cwd } = operation.options;
   const { currentVersion, newVersion } = operation.state;
